\documentclass[a4paper,english,12pt]{article}
\input{preamble}

\title{DAT510 --- Assignment 1}
\author{Christian Stigen}
\date{UiS, September \nth{18}, 2017}

\begin{document}
\maketitle

\begin{abstract}
My abstract, to be written at the end.
\end{abstract}

\section{Part I. Poly-alphabetic Ciphers}

\begin{itemize}
  \item The plaintext message you managed to decipher
  \item Describe the stragey you employed, show the details for each of the
    steps of that strategy, describe any programs you wrote show sample output
    of these programs, and show how you transformed that output into your
    solution.
\end{itemize}

\section{Part II. Simplified DES}

\subsection{Task 1: Test cases}

Implemented SDES and completed the following table.

\begin{table}[H]
  \centering
  \begin{tabular}{ccc}
    \hline \textbf{Raw key} &
           \textbf{Plaintext} &
           \textbf{Ciphertext} \\
    \hline
    \texttt{0000000000} & \texttt{00000000} & \texttt{\textbf{00000000}} \\
    \texttt{0000011111} & \texttt{11111111} & \texttt{\textbf{11111111}} \\
    \texttt{0010011111} & \texttt{11111100} & \texttt{\textbf{11111100}} \\
    \texttt{0010011111} & \texttt{10100101} & \texttt{\textbf{10100101}} \\
    \texttt{1111111111} & \texttt{\textbf{11111111}} & \texttt{00001111} \\
    \texttt{0000011111} & \texttt{\textbf{00000000}} & \texttt{01000011} \\
    \texttt{1000101110} & \texttt{\textbf{00111000}} & \texttt{00011100} \\
    \texttt{1000101110} & \texttt{\textbf{00001100}} & \texttt{11000010} \\
    \hline
  \end{tabular}
  \label{table:task1}
\end{table}

\subsection{Task 2: Test cases}

Implemented TripleSDES code and completed the following table.

\begin{table}[H]
  \centering
  \begin{tabular}{cccc}
    \hline 
      \textbf{Raw key 1} &
      \textbf{Raw key 2} &
      \textbf{Plaintext} &
      \textbf{Ciphertext} \\
    \hline

             \texttt{1000101110} &
             \texttt{0110101110} &
               \texttt{11010111} &
       \texttt{\textbf{10111001}} \\

            \texttt{1000101110} &
            \texttt{0110101110} &
              \texttt{10101010} &
      \texttt{\textbf{11100100}} \\

            \texttt{1111111111} &
            \texttt{1111111111} &
              \texttt{00000000} &
      \texttt{\textbf{11101011}} \\

            \texttt{0000000000} &
            \texttt{0000000000} &
              \texttt{01010010} &
      \texttt{\textbf{10000000}} \\

            \texttt{1000101110} &
            \texttt{0110101110} &
      \texttt{\textbf{11111101}} &
              \texttt{11100110} \\

             \texttt{1011101111} &
             \texttt{0110101110} &
       \texttt{\textbf{01001111}} &
               \texttt{01010000} \\

            \texttt{1111111111} &
            \texttt{1111111111} &
      \texttt{\textbf{10101010}} &
              \texttt{00000100} \\

            \texttt{0000000000} &
            \texttt{0000000000} &
      \texttt{\textbf{00000000}} &
              \texttt{11110000} \\

      \hline
  \end{tabular}
  \label{table:task2}
\end{table}

\subsection{Task 3: Cracking SDES and TripleDES}

\paragraph{SDES encrypted file} named \texttt{cxt1.txt} was decrypted with the
following result:

\paragraph{Key} \texttt{1111101010} or \texttt{0x3ea}

\paragraph{Plaintext}
\texttt{simplifieddesisnotsecureenoughtoprovideyousufficientsecurity}

\paragraph{Plaintext with manually inserted spaces}
\texttt{simplified des is not secure enough to provide you sufficient security}

Since the key is only 10 bits, I brute-forced it. I started with a set of all
the possible 1023 keys, then for each byte, I tried to decrypt with each key.
Assuming that the output text would be ASCII, I checked if the output byte was
within the printable ASCII range of 32--126. If it wasn't, the key was
immediately removed from the set. When the set contained a single key, I
stopped and printed the output.

\paragraph{TripleSDES encrypted file} named \texttt{cxt2.txt}

\paragraph{Key 1} 1002 / 0x3ea / 0b1111101010 (same as the above key)
\paragraph{Key 2} 351 / 0x15f / 0b1111101010
\paragraph{Plaintext}
\texttt{simplifieddesisnotsecureenoughtoprovideyousufficientsecurity} (same as
above)

This time, there are two 10-bit keys, giving the 20-bit space of possible keys.
I used the exact same strategy as above, but used a JIT-compiler to make it
break the ciphertext in around 2.5 seconds (using pypy).

The filtering mechanism was exactly the same: Remove keys that do not provide
output in the possible output space.

The running time was slower, but since it still ran in reasonable time and gave
the correct result, I didn't employ any smarter way to break it. A possible way
to do that would be to split up the three-part decryption into distinct parts.
At least the last step, decrypting the final part, I could have filtered that
alone on all possible input bytes. However, that would mean I would have to
traverse all 10-bit keys on all 8-bit inputs, so it would do it in $2^{18}$.

An alternative route would be to use a language like C to break it, which would
not be smarter in any way, just purely faster.

Had the task been to search a larger space, I would surely have figured out a
smarter way to break it.

\section{Conclusion}

A short paragraph that restates the objective from your introduction and
relates it to your results and discussion describes any future improvements on
your techniques that you would recommend.

\bibliography{references}
\bibliographystyle{ieeetr}

\end{document}
