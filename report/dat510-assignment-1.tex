\documentclass[a4paper,english,12pt]{article}
\input{preamble}

\title{DAT-510 Security and Vulnerability in Networks}
\subtitle{Assignment 1}
\author{Christian Stigen}
\date{UiS, September \nth{18}, 2017}

\begin{document}
\maketitle

% TODO: Look into MEET IN THE MIDDLE attack!! At least mention it.

\begin{abstract}
  This report presents procedures and results for recovering plaintexts and keys
  for two cipher systems --- The classical \textit{Vigenère polyalphabetic}
  substitution cipher, and the educational \textit{Simplified DES} (SDES) symmetric cipher.
%
  The Vigenère plaintext was deciphered using the \textit{Kasiski method} for
  finding key-lengths, while each corresponding Caesar alphabet was found by
  councidence counting: Each mono-alphabet was shifted to attain the highest
  English letter-frequency correlation. Recombining them produced the
  plaintext. The key was recovered simply by decrypting the ciphertext with the
  recovered plaintext.
%
  The SDES and TripleSDES keys were found through brute-forcing. While the
  10-bit SDES was simple to find, the 20-bit TripleSDES was found by splitting
  the three-part decryption function into separate lookup tables. The set of
  candidate keys were represented in a memory-efficient bitset. Keys that
  decrypted the plaintext to non-printable ASCII characters were discarded.
  The combined C++ and Python program was then able to break the key in less
  than 50 milliseconds.  Larger key-lengths would most likely be impractical to
  solve this way.
%
  As expected, this shows that both systems are readily broken with modern
  hardware, and are not secure for real-world usage.
\end{abstract}

\section{Part I --- Polyalphabetic ciphers}

Below is the raw and formatted plaintext message recovered from the Vigenère
cipher\cite{wiki:vigenere, wiki:polyalphabetic}. Spaces were added to highlight
the coincidence with the length of the key \texttt{TSHTAD}.

\begin{verbatim}
CRYPTO GRAPHY CANBES TRONGO RWEAKC RYPTOG RAPHIC STRENG
THISME ASURED INTHET IMEAND RESOUR CESITW OULDRE QUIRET
ORECOV ERTHEP LAINTE XTTHER ESULTO FSTRON GCRYPT OGRAPH
YISCIP HERTEX TTHATI SVERYD IFFICU LTTODE CIPHER WITHOU
TPOSSE SSIONO FTHEAP PROPRI ATEDEC ODINGT OOLHOW DIFFIC
ULTGIV ENALLO FTODAY SCOMPU TINGPO WERAND AVAILA BLETIM
EEVENA BILLIO NCOMPU TERSDO INGABI LLIONC HECKSA SECOND
ITISNO TPOSSI BLETOD ECIPHE RTHERE SULTOF STRONG CRYPTO
GRAPHY BEFORE THEEND OFTHEU NIVERS E
\end{verbatim}

\textit{Cryptography can be strong or weak. Cryptographic strength is measured
in the time and resources it would require to recover the plaintext.  The
result of strong cryptography is ciphertext that is very difficult to decipher
without possession of the appropriate decoding tool. How difficult given all of
today's computer power and available time, even a billion computers doing a
billion checks a second, it is not possible to decipher the result of strong
cryptography before the end of the universe.}

\subsection{Strategy}

I based my approach on the Kasiski examination\cite{dalkilic2000interactive,
wiki:kasiski.examination} with \textit{coincidence
counting}\cite{coincidence.friedman}. Briefly,

\begin{itemize}
  \item Find repeating words and the distances between them
  \item Find common factors between all the distances; their product may be the
    key length
  \item Use frequency analysis with coincidence counting to recover the
    plaintext message
  \item Decrypt Use frequency analysis to decipher the message
\end{itemize}

\paragraph{Finding repeated words}

This was fairly simple: The assignment stated that the key length was less than
ten, so I chopped the text up into $n$ pieces from $3\dots10$ and simply
searched for multiple occurrences. In pseudo-code:

\begin{verbatim}
for keylength in range(3, 10):
   for start in range(length(ciphertext)):
      key = ciphertext[start:start+length]
      positions = ciphertext.findall(key)
\end{verbatim}

I found the following repeats:

\begin{verbatim}
pos=  0       'VJFITRZJHIHB' pos=378       'VJFITRZJHIHB' dist=378
pos=  0        'VJFITRZJHIH' pos=378        'VJFITRZJHIH' dist=378
pos=  0         'VJFITRZJHI' pos=378         'VJFITRZJHI' dist=378
pos=  2         'FITRZJHIHB' pos=380         'FITRZJHIHB' dist=378
pos=  0          'VJFITRZJH' pos=378          'VJFITRZJH' dist=378
pos=  0          'VJFITRZJH' pos=378          'VJFITRZJH' dist=378
pos=  0           'VJFITRZJ' pos=378           'VJFITRZJ' dist=378
pos=  0            'VJFITRZ' pos=378            'VJFITRZ' dist=378
pos=  0            'VJFITRZ' pos=378            'VJFITRZ' dist=378
pos=  0             'VJFITR' pos=378             'VJFITR' dist=378
pos=  6             'ZJHIHB' pos=384             'ZJHIHB' dist=378
pos=  0             'VJFITR' pos=378             'VJFITR' dist=378
pos=  6             'ZJHIHB' pos=384             'ZJHIHB' dist=378
pos=  0              'VJFIT' pos=378              'VJFIT' dist=378
pos=  5              'RZJHI' pos=383              'RZJHI' dist=378
pos=260              'VFPXM' pos=302              'VFPXM' dist=42
pos=  2              'FITRZ' pos=380              'FITRZ' dist=378
pos=  7              'JHIHB' pos=385              'JHIHB' dist=378
pos=  0               'VJFI' pos=378               'VJFI' dist=378
pos=  4               'TRZJ' pos=382               'TRZJ' dist=378
pos=  8               'HIHB' pos=386               'HIHB' dist=378
pos=192               'MHVL' pos=342               'MHVL' dist=150
pos=260               'VFPX' pos=302               'VFPX' dist=42
pos=282               'UDLM' pos=348               'UDLM' dist=66
pos=  2               'FITR' pos=380               'FITR' dist=378
pos=  6               'ZJHI' pos=384               'ZJHI' dist=378
Distances: 378 66 42 150
Common factors: 2 3
Perhaps the keylength is 6
Ciphertext in 6 columns
VJFITR
ZJHIHB
VSUUEV
MJVGGR
KOLTKF
KQWMOJ
KSWAIF
... 64 more
\end{verbatim}

TODO: Describe strategy you employed. SHow the details for each of the steps of
the strategy. Describe any programs you wrote. Show sample output of these
programs. Show how you transformed that output into your solution.

\begin{itemize}
  \item The plaintext message you managed to decipher
  \item Describe the stragey you employed, show the details for each of the
    steps of that strategy, describe any programs you wrote show sample output
    of these programs, and show how you transformed that output into your
    solution.
\end{itemize}

\section{Part II. Simplified DES}

\subsection{Task 1: Test cases}

Implemented SDES\cite{stallings2006cryptography} and completed the following
table.

\begin{table}[H]
  \centering
  \begin{tabular}{ccc}
    \hline \textbf{Raw key} &
           \textbf{Plaintext} &
           \textbf{Ciphertext} \\
    \hline
    \texttt{0000000000} & \texttt{00000000} & \texttt{\textbf{11110000}} \\
    \texttt{0000011111} & \texttt{11111111} & \texttt{\textbf{11100001}} \\
    \texttt{0010011111} & \texttt{11111100} & \texttt{\textbf{10011101}} \\
    \texttt{0010011111} & \texttt{10100101} & \texttt{\textbf{10010000}} \\
    \texttt{1111111111} & \texttt{\textbf{11111111}} & \texttt{00001111} \\
    \texttt{0000011111} & \texttt{\textbf{00000000}} & \texttt{01000011} \\
    \texttt{1000101110} & \texttt{\textbf{00111000}} & \texttt{00011100} \\
    \texttt{1000101110} & \texttt{\textbf{00001100}} & \texttt{11000010} \\
    \hline
  \end{tabular}
  \label{table:task1}
\end{table}

\subsection{Task 2: Test cases}

Implemented TripleSDES code and completed the following table.

\begin{table}[H]
  \centering
  \begin{tabular}{cccc}
    \hline 
      \textbf{Raw key 1} &
      \textbf{Raw key 2} &
      \textbf{Plaintext} &
      \textbf{Ciphertext} \\
    \hline

             \texttt{1000101110} &
             \texttt{0110101110} &
               \texttt{11010111} &
       \texttt{\textbf{10111001}} \\

            \texttt{1000101110} &
            \texttt{0110101110} &
              \texttt{10101010} &
      \texttt{\textbf{11100100}} \\

            \texttt{1111111111} &
            \texttt{1111111111} &
              \texttt{00000000} &
      \texttt{\textbf{11101011}} \\

            \texttt{0000000000} &
            \texttt{0000000000} &
              \texttt{01010010} &
      \texttt{\textbf{10000000}} \\

            \texttt{1000101110} &
            \texttt{0110101110} &
      \texttt{\textbf{11111101}} &
              \texttt{11100110} \\

             \texttt{1011101111} &
             \texttt{0110101110} &
       \texttt{\textbf{01001111}} &
               \texttt{01010000} \\

            \texttt{1111111111} &
            \texttt{1111111111} &
      \texttt{\textbf{10101010}} &
              \texttt{00000100} \\

            \texttt{0000000000} &
            \texttt{0000000000} &
      \texttt{\textbf{00000000}} &
              \texttt{11110000} \\

      \hline
  \end{tabular}
  \label{table:task2}
\end{table}

\subsection{Task 3: Cracking SDES and TripleDES}

\paragraph{SDES encrypted file} named \texttt{cxt1.txt} was decrypted with the
following result:

\paragraph{Key} \texttt{1111101010} or \texttt{0x3ea}

\paragraph{Plaintext}
\texttt{simplifieddesisnotsecureenoughtoprovideyousufficientsecurity}

\paragraph{Plaintext with manually inserted spaces}
\texttt{simplified des is not secure enough to provide you sufficient security}

Since the key is only 10 bits, I brute-forced it. I started with a set of all
the possible 1023 keys, then for each byte, I tried to decrypt with each key.
Assuming that the output text would be ASCII, I checked if the output byte was
within the printable ASCII range of 32--126. If it wasn't, the key was
immediately removed from the set. When the set contained a single key, I
stopped and printed the output.

\paragraph{TripleSDES encrypted file} named \texttt{cxt2.txt}

\paragraph{Key 1} 1002 / 0x3ea / 0b1111101010 (same as the above key)
\paragraph{Key 2} 351 / 0x15f / 0b1111101010
\paragraph{Plaintext}
\texttt{simplifieddesisnotsecureenoughtoprovideyousufficientsecurity} (same as
above)

This time, there are two 10-bit keys, giving the 20-bit space of possible keys.
I used the exact same strategy as above, but used a JIT-compiler to make it
break the ciphertext in around 2.5 seconds (using pypy).

The filtering mechanism was exactly the same: Remove keys that do not provide
output in the possible output space.

The running time was slower, but since it still ran in reasonable time and gave
the correct result, I didn't employ any smarter way to break it. A possible way
to do that would be to split up the three-part decryption into distinct parts.
At least the last step, decrypting the final part, I could have filtered that
alone on all possible input bytes. However, that would mean I would have to
traverse all 10-bit keys on all 8-bit inputs, so it would do it in $2^{18}$.

An alternative route would be to use a language like C to break it, which would
not be smarter in any way, just purely faster.

Had the task been to search a larger space, I would surely have figured out a
smarter way to break it.

\section{Conclusion}

A short paragraph that restates the objective from your introduction and
relates it to your results and discussion describes any future improvements on
your techniques that you would recommend.

\bibliography{references}
\bibliographystyle{ieeetr}

\end{document}
