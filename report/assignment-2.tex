\documentclass[a4paper,english,12pt]{article}
\input{preamble}

\title{DAT-510 Assignment 2}
\author{Christian Stigen}
\date{UiS, October \nth{9}, 2017}

\begin{document}
\maketitle

\begin{abstract}
  This report presents an implementation of a secure, public key communication
  system between two parties.
  %
  Each party generates private and public keys using the Blum Blum Shub
  PRNG, with 512-bit primes that are resistant to subgroup attacks. Suitable
  Blum numbers are found through trial Miller-Rabin primality tests.
  %
  A shared key is established between the parties with the \textit{mod p}
  Diffie-Hellman key exchange, using recommended and publicly scrutinized
  2048-bit parameters from the IKE protocol.
  %
  The shared key then seeds another Blum Blum Shub PRNG to create a common
  sequence of 20-bit keys for use with the TripleSDES stream cipher, used to
  encrypt and decrypt messages.
  %
  The program communicates over an TCP/IP socket. After the key exchange has
  been finished, an chat window opens. The two parties can then proceed to chat
  securely over a public channel. However, networking is a big topic and
  details around stability are out of scope for this project. In particular,
  the two CSPRNGs are susceptible to synchronization issues if the message rate
  is high. Reseeding, while a security issue, has also been deemed out of
  scope.
  %
  While working as advertised, this student project has a few obvious
  weaknesses: A real system would not use the educational TripleSDES stream
  cipher. Furthermore, by reuses the Diffie-Hellman parameters in the Blum Blum
  Shub stream cipher key generator, the space of suitable primes is reduced,
  possibly weakening the system.
\end{abstract}

\section{Introduction}
The objective in this project was to create a program for securely sending data
between two parties \textit{Alice} and \textit{Bob} over an insecure channel.

In the project description, the requirement was to use public key cryptography
to establish a shared key. The key would then seed a cryptographically secure
pseudo-random number generator (CSPRNG), which would then create a shared,
secret key for encrypting and decrypting data with a stream cipher.

More specifically, the program would consist of three major parts:
\begin{itemize}
  \item The Diffie-Hellman key exchange \cite{dh},
  \item a cryptographically secure pseudo-random number generator (CSPRNG)
  \item and a symmetric cipher.
\end{itemize}

\section{Design and implementation}
The program consists of the following parts:
\begin{itemize}
  \item The Diffie-Hellman \cite{dh} (DH) key exchange
    \begin{itemize}
      \item Selection and verification of global DH parameters $p, q, g$
      \item Generation of private and public keys using a random Blum Blum Shub CSPRNG
      \item Computing a shared key $K_{ab}$ between Alice and Bob
    \end{itemize}
  \item Establishing a common key $K$ with another Blum Blum Shub CSPRNG. It
    reuses the parameters $p$ and $q$ and uses the shared key $K_{ab}$ as its
    seed.
  \item Encrypting or decrypting the data using TripleSDES stream cipher
    \cite{sdes}, where each byte is using a separate 20-bit key from the
    CSPRNG.
\end{itemize}

\subsection{Choice of programming language}
Writing a secure, production-ready cryptography system is a serious
undertaking. While security is paramount, such a system should operate quickly
as well. This being a student project, I have chosen flexibility above
speed. Aspects concerning the security of the implementation have been noted
throughout this report.

I have chosen to use Python as the sole programming language, mostly because it
comes with big integer support built-in. A faster language, such as C or C++,
would require to use the GMP library \cite{wiki:gmp} for implementing bignums.
This requires installing additional packages, and I have therefore chosen not
to use those languages in this project.

\subsection{Choice of global parameters}
While the implementation contains code for choosing $p$ and $q$ for the
Diffie-Hellman key exchange, I have chosen numbers, with a generator $g$, from
\cite{rfc3526}. The arguments were originally made for use with the IKE key
exchange protocol (using Diffie-Hellman), and have been found ot have good
number theoretic security properties.

In \cite{dh.params} we see that choosing good parameters for the Diffie-Hellman
key exchange is very hard to make right. Because of that, many public key
cryptography systems in use today reuse parameters from well-known, predefined
groups that are available publicly. The problem is that those groups may
potentially have been broken by large organizations, and thus the key exchanges
may be prone to attacks. This particularly applies to the groups with a low
number of bits. The recommendation in the paper is to use at least 2048-bit
groups today, and use ones that have been well chosen. 

In particular, \cite{dh.params} warns about generating the parameters yourself,
precisely because it is so hard to make it right and choose good, secure
parameters. Because of that, I have chosen to use DH parameters from
\cite{rfc3526}. To show that I am able to generate parameters myself, I have
done so in the function \texttt{generate\_dh\_params} in the file
\texttt{app.py}. An example output is given in listing \vref{verb:dh.ex}.

\begin{lstlisting}[caption={Finding Diffie-Hellman parameters}, label=verb:dh.ex]
Example 8-bit Diffie-Hellman global parameters:
         q = 83
           = 0x53
  p (2q+1) = 167
           = 0xa7
   found g = 2

Example 16-bit Diffie-Hellman global parameters:
         q = 30689
           = 0x77e1
  p (2q+1) = 61379
           = 0xefc3
   found g = 3
\end{lstlisting}

\subsection{Choice of CSPRNG}
I have chosen to use the Blum Blum Shub \cite{bbs} pseudo-random number
generator. This section will give details on the implementation.

The first step is to find two large prime numbers $p$ and $q$. I have
implemented the Miller-Rabin \cite{miller.rabin} primality test to generate
them.
%
If the bit length is 512, I select a random integer between $2^{512-1}$ and
$2^{512}-1$, then perform the Miller-Rabin test with an appropriate accuracy
setting. There are two things to consider here: The choice of pseud-random
number generator (PRNG) for choosing a candidate, and the accuracy setting of
the Miller-Rabin test.

\paragraph{The PRNG} for choosing a candidate prime is done with the built-in
\texttt{random.randint} function in Python. This is not a cryptographically
secure pseud-random number generator (CSPRNG). One could investigate whether a
non-CSPRNG would weaken the BBS algorithm. But the number of primes between
$2^{512-1}$ and $2^{512}-1$ is \textit{huge} \cite{wiki:prime.counting}, so I
have chosen not to investigate this issue any further.

\paragraph{The accuracy setting} is discussed in \cite{damgaard1993average}, which
provides a method to select the accuracy based on a desired error bound. I have
not implemented an automatic selection of the accuracy parameter in the code,
however. In the paper, they state that a $k=600$-bit number with $t=1$
iteration, the upper bound for the probability that the Miller-Rabin test
actually produces a composite number is $p_{600, 1} \leqslant 2^{-75}$.

If the test is negative, I try another number. If it is true, I accept
it. However, the Miller-Rabin primality test is \textit{probabilistic}. While
it will always be correct if it says a number is not prime, it may give false
positives, saying a number is \textit{probably} prime, but cannot be certain
about it. At this point in the code, I do not perform any further checks on the
number. This is a weakness of the algorithm that should be addressed in a
production system.

The primes $p$ and $q$ must be congruent to $4 (mod 3)$, meaning that $p mod 4
== 3$ and likewise for $q$.

\section{Test results}

\section{Discussion}

\section{Conclusion}

\bibliography{assignment-2}
\bibliographystyle{ieeetr}

\end{document}
