Found repeated words
Found their distances
Found the common factors in the distances: 2 3
Those numbers multiplited is 6, so suspect keylength is 6 characters.

Output:

pos=  0       'VJFITRZJHIHB' pos=378       'VJFITRZJHIHB' dist=378
pos=  0        'VJFITRZJHIH' pos=378        'VJFITRZJHIH' dist=378
pos=  0         'VJFITRZJHI' pos=378         'VJFITRZJHI' dist=378
pos=  2         'FITRZJHIHB' pos=380         'FITRZJHIHB' dist=378
pos=  0          'VJFITRZJH' pos=378          'VJFITRZJH' dist=378
pos=  0          'VJFITRZJH' pos=378          'VJFITRZJH' dist=378
pos=  0           'VJFITRZJ' pos=378           'VJFITRZJ' dist=378
pos=  0            'VJFITRZ' pos=378            'VJFITRZ' dist=378
pos=  0            'VJFITRZ' pos=378            'VJFITRZ' dist=378
pos=  0             'VJFITR' pos=378             'VJFITR' dist=378
pos=  6             'ZJHIHB' pos=384             'ZJHIHB' dist=378
pos=  0             'VJFITR' pos=378             'VJFITR' dist=378
pos=  6             'ZJHIHB' pos=384             'ZJHIHB' dist=378
pos=  0              'VJFIT' pos=378              'VJFIT' dist=378
pos=  5              'RZJHI' pos=383              'RZJHI' dist=378
pos=260              'VFPXM' pos=302              'VFPXM' dist=42
pos=  2              'FITRZ' pos=380              'FITRZ' dist=378
pos=  7              'JHIHB' pos=385              'JHIHB' dist=378
pos=  0               'VJFI' pos=378               'VJFI' dist=378
pos=  4               'TRZJ' pos=382               'TRZJ' dist=378
pos=  8               'HIHB' pos=386               'HIHB' dist=378
pos=192               'MHVL' pos=342               'MHVL' dist=150
pos=260               'VFPX' pos=302               'VFPX' dist=42
pos=282               'UDLM' pos=348               'UDLM' dist=66
pos=  2               'FITR' pos=380               'FITR' dist=378
pos=  6               'ZJHI' pos=384               'ZJHI' dist=378
Distances: 378 66 42 150
Common factors: 2 3
Perhaps the keylength is 6
Ciphertext in 6 columns
VJFITR
ZJHIHB
VSUUEV
MJVGGR
KOLTKF
KQWMOJ
KSWAIF
... 64 more

Took every 6 characters from ciphertext, printed above each other.
Each vertical column should be encoded using same substitution alphabet.

Took frequency counts for each column. Had 6 tables if substitutions. From this
point on, I just did it by trial and error.

The variable "monos" holds the six monoalphabetic ciphertexts. I started by
assigning the value "e" for the top letter in each.

>>> show_freqs(monos[0])
   0.12 M  -  0.12 E
   0.10 L  -  0.09 T
   0.09 H  -  0.08 A
   0.07 X  -  0.08 O
   0.07 V  -  0.07 I
   0.07 K  -  0.07 N
   0.07 B  -  0.06 S
   0.06 U  -  0.06 R
   0.04 Z  -  0.06 H
   0.04 Y  -  0.04 D
   0.04 T  -  0.04 L
   0.04 E  -  0.03 U
   0.03 P  -  0.03 C
   0.03 G  -  0.03 M
   0.03 A  -  0.02 F
   0.01 W  -  0.02 Y
   0.01 R  -  0.02 W
   0.01 Q  -  0.02 G
   0.01 N  -  0.02 P
   0.01 J  -  0.01 B
   0.01 I  -  0.01 V
>>> tables[0]["M"] = "e"

... and so on.

Here is the table after all the top two letters of every alphabet has been
assigned the characters "e" and "t":

  cipher VZVMKK KLMTBB KVHJHX EQXYZH RAMLBE VPMLYI THHWNX YLMPTU XUGMBE ALBMUX KLLVZU MHG
  plain  ...e.. .te... ...... ...... ..et.. ..et.. ...... .te... ...e.. .t.e.. .tt... e..
  cipher JJSJOQ SLZKFE WWMMJJ SLKKUY AWLNXL AAHKLJ LVGADF LUAWND WAUWFD WWLHDU LMLJJW ZXA
  plain  ...... .e.... tt.... .e.... .te..e ....e. e..... e..t.. t..t.. tte... e.e..t ...
  cipher FHUVLW WYPBAL ZZSPLA PABAYY ZYOLMA WAVPOV LPSMAH VVUYHL CSVYNP JJPVLP OSYFHM LAC
  plain  ....t. ..e..t ...et. e..... ...t.. ...e.. te.... .....t .....e ..e.te ...... t..
  cipher IIUGTM AXLKAT HBWKVA GAEKRT VMTKBH AALHXI WGAYZE WFZTBM XEFLTH DHLLMI XMHIIH XAX
  plain  ...... e...e. t....e .e.... .....t ee.t.. ..e... ...... .....t .t.... ..t..t .e.
  cipher THEGKO INMEEN UTREOE TETOPP IETYCD EOSNAR EGOIIL APPNLI NIPDBN SNNSOH RONTHR NER
  plain  ..t... .e.tte ...t.t .t.... .t.... t..e.. t..... ...e.. e....e .ee... ..e... et.
  cipher RBVRFJ FJHGWG UZHWYS HURQWK SALGXH UXHRSL FWZFYR BXRGDP DRXRLF DGRLGH HIJRBH GXV
  plain  e..e.. ..t... ..t... t.e... .....t ..te.. .....e ..e... .e.e.. ..e..t t..e.t ...

There are no obvious errors so far, so I just continued down the frequency
list. Errors would be triple Es or Ts, or other invalid sequences.

At this point, I spotted a double "aa", which might be wrong. The problem is
that the spaces have been removed, so it's very hard to see whether a double a
is an error or not. I'll leave it so far:

  cipher VZVMKK KLMTBB KVHJHX EQXYZH RAMLBE VPMLYI THHWNX YLMPTU XUGMBE ALBMUX KLLVZU MHG
  plain  ...e.. .te... ..a.a. .....a ..et.. ..et.. .aa... .te... ...e.. .t.e.. .tt... ea.
  cipher JJSJOQ SLZKFE WWMMJJ SLKKUY AWLNXL AAHKLJ LVGADF LUAWND WAUWFD WWLHDU LMLJJW ZXA
  plain  aa.a.. .e.... tt..aa .e.... .te..e ....ea e..... e..t.. t..t.. tte... e.eaat ...
  cipher FHUVLW WYPBAL ZZSPLA PABAYY ZYOLMA WAVPOV LPSMAH VVUYHL CSVYNP JJPVLP OSYFHM LAC
  plain  ....t. ..e..t ...et. e..... ...t.. ...e.. te.... .....t .....e ..e.te ...... t..
  cipher IIUGTM AXLKAT HBWKVA GAEKRT VMTKBH AALHXI WGAYZE WFZTBM XEFLTH DHLLMI XMHIIH XAX
  plain  ...... e...e. t....e .e.... .....t ee.t.. ..e... ...... .....t .t.... ..t..t .e.
  cipher THEGKO INMEEN UTREOE TETOPP IETYCD EOSNAR EGOIIL APPNLI NIPDBN SNNSOH RONTHR NER
  plain  ..t... .e.tte ...t.t .t.... .t.... t..e.. t..... ...e.. e....e .ee... ..e... et.
  cipher RBVRFJ FJHGWG UZHWYS HURQWK SALGXH UXHRSL FWZFYR BXRGDP DRXRLF DGRLGH HIJRBH GXV
  plain  e..e.. ..t... ..t... t.e... .....t ..te.. .....e ..e... .e.e.. ..e..t t..e.t ...

Tables at this point:

[{'H': 'a', 'M': 'e', 'L': 't'}, {'J': 'a', 'L': 'e', 'W': 't'}, {'A': 'a',
'P': 'e', 'L': 't'}, {'A': 'e', 'H': 't', 'T': 'o', 'X': 'a'}, {'E': 't', 'N':
'e'}, {'H': 't', 'R': 'e'}]

For the nth time, I started over again. If I have three top letters with the
same relative frequency, it's best not to assign them, and instead assign those
that there can be little doubt about, for each of the six tables. That way, I
can look for very comon words, like "THE". That's what I'm doing now. The
current situation is:

>>> reb()
  cipher VZVMKK KLMTBB KVHJHX EQXYZH RAMLBE VPMLYI THHWNX YLMPTU XUGMBE ALBMUX KLLVZU MHG
  plain  ...e.. .te... ...... ...... ..et.. ..et.. ...... .te... ...e.. .t.e.. .tt... e..
  cipher JJSJOQ SLZKFE WWMMJJ SLKKUY AWLNXL AAHKLJ LVGADF LUAWND WAUWFD WWLHDU LMLJJW ZXA
  plain  ...... .e.... tt.... .e.... .te..e ....e. e..... e..t.. t..t.. tte... e.e..t ...
  cipher FHUVLW WYPBAL ZZSPLA PABAYY ZYOLMA WAVPOV LPSMAH VVUYHL CSVYNP JJPVLP OSYFHM LAC
  plain  ...... ...... ...... ...... ...... ...... ...... ...... ...... ...... ...... ...
  cipher IIUGTM AXLKAT HBWKVA GAEKRT VMTKBH AALHXI WGAYZE WFZTBM XEFLTH DHLLMI XMHIIH XAX
  plain  ...... e...e. t....e .e.... .....t ee.t.. ..e... ...... .....t .t.... ..t..t .e.
  cipher THEGKO INMEEN UTREOE TETOPP IETYCD EOSNAR EGOIIL APPNLI NIPDBN SNNSOH RONTHR NER
  plain  ...... ...... ...... ...... ...... ...... ...... ...... ...... ...... ...... ...
  cipher RBVRFJ FJHGWG UZHWYS HURQWK SALGXH UXHRSL FWZFYR BXRGDP DRXRLF DGRLGH HIJRBH GXV
  plain  e..e.. ..t... ..t... t.e... .....t ..te.. .....e ..e... .e.e.. ..e..t t..e.t ...
>>> tables
[{'M': 'e', 'L': 't'}, {'L': 'e', 'W': 't'}, {}, {'A': 'e', 'H': 't'}, {}, {'H': 't', 'R': 'e'}]

At "ALBMUX" there is a possibility that "B" is an "h" in table[2]. This is also
the case at "HURQWK", but in table[1].
